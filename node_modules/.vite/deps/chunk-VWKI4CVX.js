// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var r = Symbol();
var n = (e2, t2) => new Proxy(e2, t2);
var o = Object.getPrototypeOf;
var s = /* @__PURE__ */ new WeakMap();
var c = (e2) => e2 && (s.has(e2) ? s.get(e2) : o(e2) === Object.prototype || o(e2) === Array.prototype);
var l = (e2) => "object" == typeof e2 && null !== e2;
var a = /* @__PURE__ */ new WeakMap();
var f = (e2) => e2[r] || e2;
var i = (s2, l2, p2) => {
  if (!c(s2))
    return s2;
  const y2 = f(s2), u = ((e2) => Object.isFrozen(e2) || Object.values(Object.getOwnPropertyDescriptors(e2)).some((e3) => !e3.writable))(y2);
  let g2 = p2 && p2.get(y2);
  return g2 && g2[1].f === u || (g2 = ((n2, o2) => {
    const s3 = { f: o2 };
    let c2 = false;
    const l3 = (t2, r2) => {
      if (!c2) {
        let o3 = s3.a.get(n2);
        o3 || (o3 = /* @__PURE__ */ new Set(), s3.a.set(n2, o3)), r2 && o3.has(e) || o3.add(t2);
      }
    }, a2 = { get: (e2, t2) => t2 === r ? n2 : (l3(t2), i(e2[t2], s3.a, s3.c)), has: (e2, r2) => r2 === t ? (c2 = true, s3.a.delete(n2), true) : (l3(r2), r2 in e2), getOwnPropertyDescriptor: (e2, t2) => (l3(t2, true), Object.getOwnPropertyDescriptor(e2, t2)), ownKeys: (t2) => (l3(e), Reflect.ownKeys(t2)) };
    return o2 && (a2.set = a2.deleteProperty = () => false), [a2, s3];
  })(y2, u), g2[1].p = n(u ? ((e2) => {
    let t2 = a.get(e2);
    if (!t2) {
      if (Array.isArray(e2))
        t2 = Array.from(e2);
      else {
        const r2 = Object.getOwnPropertyDescriptors(e2);
        Object.values(r2).forEach((e3) => {
          e3.configurable = true;
        }), t2 = Object.create(o(e2), r2);
      }
      a.set(e2, t2);
    }
    return t2;
  })(y2) : y2, g2[0]), p2 && p2.set(y2, g2)), g2[1].a = l2, g2[1].c = p2, g2[1].p;
};
var p = (e2, t2) => {
  const r2 = Reflect.ownKeys(e2), n2 = Reflect.ownKeys(t2);
  return r2.length !== n2.length || r2.some((e3, t3) => e3 !== n2[t3]);
};
var y = (t2, r2, n2, o2) => {
  if (Object.is(t2, r2))
    return false;
  if (!l(t2) || !l(r2))
    return true;
  const s2 = n2.get(f(t2));
  if (!s2)
    return true;
  if (o2) {
    const e2 = o2.get(t2);
    if (e2 && e2.n === r2)
      return e2.g;
    o2.set(t2, { n: r2, g: false });
  }
  let c2 = null;
  for (const l2 of s2) {
    const s3 = l2 === e ? p(t2, r2) : y(t2[l2], r2[l2], n2, o2);
    if (true !== s3 && false !== s3 || (c2 = s3), c2)
      break;
  }
  return null === c2 && (c2 = true), o2 && o2.set(t2, { n: r2, g: c2 }), c2;
};
var g = (e2) => c(e2) && e2[r] || null;
var b = (e2, t2 = true) => {
  s.set(e2, t2);
};
var O = (e2, t2) => {
  const r2 = [], n2 = /* @__PURE__ */ new WeakSet(), o2 = (e3, s2) => {
    if (n2.has(e3))
      return;
    l(e3) && n2.add(e3);
    const c2 = l(e3) && t2.get(f(e3));
    c2 ? c2.forEach((t3) => {
      o2(e3[t3], s2 ? [...s2, t3] : [t3]);
    }) : s2 && r2.push(s2);
  };
  return o2(e2), r2;
};

// node_modules/valtio/esm/vanilla.js
var isObject = (x) => typeof x === "object" && x !== null;
var refSet = /* @__PURE__ */ new WeakSet();
var VERSION = (import.meta.env && import.meta.env.MODE) !== "production" ? Symbol("VERSION") : Symbol();
var LISTENERS = (import.meta.env && import.meta.env.MODE) !== "production" ? Symbol("LISTENERS") : Symbol();
var SNAPSHOT = (import.meta.env && import.meta.env.MODE) !== "production" ? Symbol("SNAPSHOT") : Symbol();
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), PROMISE_RESULT = (import.meta.env && import.meta.env.MODE) !== "production" ? Symbol("PROMISE_RESULT") : Symbol(), PROMISE_ERROR = (import.meta.env && import.meta.env.MODE) !== "production" ? Symbol("PROMISE_ERROR") : Symbol(), snapshotCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (version, target, receiver) => {
  const cache = snapshotCache.get(receiver);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snapshot2 = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  b(snapshot2, true);
  snapshotCache.set(receiver, [version, snapshot2]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key, receiver);
    if (refSet.has(value)) {
      b(value, false);
      snapshot2[key] = value;
    } else if (value instanceof Promise) {
      if (PROMISE_RESULT in value) {
        snapshot2[key] = value[PROMISE_RESULT];
      } else {
        const errorOrPromise = value[PROMISE_ERROR] || value;
        Object.defineProperty(snapshot2, key, {
          get() {
            if (PROMISE_RESULT in value) {
              return value[PROMISE_RESULT];
            }
            throw errorOrPromise;
          }
        });
      }
    } else if (value == null ? void 0 : value[LISTENERS]) {
      snapshot2[key] = value[SNAPSHOT];
    } else {
      snapshot2[key] = value;
    }
  });
  return Object.freeze(snapshot2);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = /* @__PURE__ */ new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }
      if (prop === LISTENERS) {
        return listeners;
      }
      if (prop === SNAPSHOT) {
        return createSnapshot(version, target, receiver);
      }
      return Reflect.get(target, prop, receiver);
    },
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && objectIs(prevValue, value)) {
        return true;
      }
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (isObject(value)) {
        value = g(value) || value;
      }
      let nextValue;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) {
        nextValue = value;
      } else if (value instanceof Promise) {
        nextValue = value.then((v) => {
          nextValue[PROMISE_RESULT] = v;
          notifyUpdate(["resolve", [prop], v]);
          return v;
        }).catch((e2) => {
          nextValue[PROMISE_ERROR] = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else if (value == null ? void 0 : value[LISTENERS]) {
        nextValue = value;
        nextValue[LISTENERS].add(getPropListener(prop));
      } else if (canProxy(value)) {
        nextValue = proxy(value);
        nextValue[LISTENERS].add(getPropListener(prop));
      } else {
        nextValue = value;
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  proxyFunction2,
  refSet,
  VERSION,
  LISTENERS,
  SNAPSHOT,
  objectIs,
  newProxy,
  canProxy,
  PROMISE_RESULT,
  PROMISE_ERROR,
  snapshotCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function getVersion(proxyObject) {
  return isObject(proxyObject) ? proxyObject[VERSION] : void 0;
}
function subscribe(proxyObject, callback, notifyInSync) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[LISTENERS])) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        callback(ops.splice(0));
      });
    }
  };
  proxyObject[LISTENERS].add(listener);
  return () => {
    proxyObject[LISTENERS].delete(listener);
  };
}
function snapshot(proxyObject) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[SNAPSHOT])) {
    console.warn("Please use proxy object");
  }
  return proxyObject[SNAPSHOT];
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
var unstable_buildProxyFunction = buildProxyFunction;

export {
  i,
  y,
  O,
  proxy,
  getVersion,
  subscribe,
  snapshot,
  ref,
  unstable_buildProxyFunction
};
//# sourceMappingURL=chunk-VWKI4CVX.js.map
